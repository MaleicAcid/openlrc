import math
import sys
from dataclasses import dataclass
from typing import List, Union

import opencc
from langcodes import Language

from openlrc.logger import logger
from openlrc.utils import extend_filename, parse_timestamp, format_timestamp


@dataclass
class LRCElement:
    """
    Save a LRC format element.
    """
    start: float
    end: Union[float, None]
    text: str

    @property
    def duration(self):
        if self.end:
            return self.end - self.start
        else:
            return sys.maxsize  # Fake int infinity


class LRC:
    """
    Save a LRC format data.
    """

    def __init__(self, lrc_name=None):
        self.lrc_name = lrc_name
        self.lang = self.get_lrc_lang(lrc_name)
        self.elements: List[LRCElement] = []

        if lrc_name:
            self.elements = self.read_lrc(file=lrc_name)

    def read_lrc(self, file):
        """
        Read lrc file and return a list of LRCElement.
        """
        with open(file, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        elements = []

        for line in lines:
            if line.startswith('['):
                start, text = line.split(']', 1)
                start = parse_timestamp(start[1:])
                text = text.strip()
                elements.append(LRCElement(start, None, text))

        for i, element in enumerate(elements[:-1]):
            element.end = elements[i + 1].start

        return elements

    def save_lrc(self, file):
        """
        Save lrc file.
        """
        with open(file, 'w', encoding='utf-8') as f:
            print(f'LRC generated by https://github.com/zh-plus/Open-Lyrics, lang={self.lang}', file=f, flush=True)
            for i, element in enumerate(self.elements):
                print(
                    f'[{format_timestamp(element.start)}] {element.text}',
                    file=f,
                    flush=True,
                )

                if i != len(self.elements) - 1 and element.end != self.elements[i + 1].start:
                    print(f'[{format_timestamp(element.end)}]', file=f, flush=True)

        return file

    def get_system_prompt(self, src_lang, target_lang, prompter):
        system_prompt = str(prompter).format(
            src_lang=Language.get(self.lang if not src_lang else src_lang).display_name('en'),
            target_lang=Language.get(target_lang).display_name('en')
        )
        # Prevent translating text into Traditional Chinese
        if target_lang == 'zh-cn':
            system_prompt.replace(Language.get(target_lang).display_name('en'), 'Mandarin Chinese')

        return system_prompt

    def get_texts(self):
        return [e.text for e in self.elements]

    def set_texts(self, texts):
        # Check length
        assert len(texts) == len(self.elements)

        for i, text in enumerate(texts):
            self.elements[i].text = text

    @staticmethod
    def get_lrc_lang(lrc_name):
        with open(lrc_name, 'r', encoding='utf-8') as f:
            first_line = f.readline()

        if first_line.startswith('LRC generated by'):
            lang = first_line.split('lang=')[-1].strip()
            return lang


class LRCOptimizer:
    def __init__(self, lrc: Union[str, LRC]):
        if isinstance(lrc, str):
            lrc = LRC(lrc)

        self.lrc = lrc

    @property
    def lrc_name(self):
        return self.lrc.lrc_name

    def merge_same_lyrics(self):
        """
        Merge the same text.
        """
        new_elements = []

        for i, element in enumerate(self.lrc.elements):
            if i == 0 or element.text != new_elements[-1].text:
                new_elements.append(element)
            else:
                new_elements[-1].end = element.end

        logger.debug(f'Merge same text: {len(self.lrc.elements)} -> {len(new_elements)}')

        self.lrc.elements = new_elements

    def merge_short_lyrics(self, threshold=2):
        """
        Merge the short text.
        """
        new_elements = []

        for i, element, in enumerate(self.lrc.elements):
            if i == 0 or element.duration >= threshold:
                new_elements.append(element)
            else:
                new_elements[-1].text += ' ' + element.text
                new_elements[-1].end = element.end

        logger.debug(f'Merge short text: {len(self.lrc.elements)} -> {len(new_elements)}')

        self.lrc.elements = new_elements

    def merge_same_words(self):
        """
        Merge the same pattern in one lyric.
        :return:
        """
        new_elements = self.lrc.elements

        def get_repeat(text):
            """
            Check if the text is repeated for [1-4] words.
            """
            for i in range(1, 5):
                repeating_num = math.floor(len(text) / float(i))
                if text[:i] * repeating_num == text[:i * repeating_num]:
                    return text[:i]
            return None

        for i in range(len(new_elements)):
            repeat_text = get_repeat(new_elements[i].text)
            if repeat_text:
                new_elements[i].text = repeat_text + '...(Repeat)'
                logger.debug(f'Merge same words: {repeat_text}')

        logger.debug('Merge same words done.')

        self.lrc.elements = new_elements

    def cut_long_lyrics(self, threshold=125, keep=20):
        new_elements = self.lrc.elements

        for i, element in enumerate(new_elements):
            if len(element.text) > threshold:
                logger.warning(f'Cut long text: {element.text}\nInto: {element.text[:keep]}...')
                new_elements[i].text = element.text[:keep] + f'(Cut to {keep})'

        logger.debug('Cut long text done.')

        self.lrc.elements = new_elements

    def traditional2mandarin(self):
        new_elements = self.lrc.elements

        converter = opencc.OpenCC('t2s.json')
        for i, element in enumerate(new_elements):
            new_elements[i].text = converter.convert(element.text)

        logger.debug('Traditional Chinese to Mandarin done.')

        self.lrc.elements = new_elements

    def remove_unk(self):
        new_elements = self.lrc.elements

        for i, element in enumerate(new_elements):
            new_elements[i].text = element.text.replace('<unk>', ' ')

        logger.debug('Remove <unk> done.')

        self.lrc.elements = new_elements

    def perform_all(self, t2m=False):
        for _ in range(2):
            self.merge_same_lyrics()
            self.merge_short_lyrics()
            # self.merge_same_words()
            self.cut_long_lyrics()
            self.remove_unk()

            if t2m or self.lrc.lang.lower() == 'zh-cn':
                self.traditional2mandarin()

    def save(self, output_lrc_name=None):
        optimized_name = extend_filename(self.lrc_name, '_optimized') if not output_lrc_name else output_lrc_name
        self.lrc.save_lrc(optimized_name)
        logger.info(f'Optimized LRC file saved to {optimized_name}')
        return optimized_name
