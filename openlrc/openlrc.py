import os

from openlrc.logger import logger
from openlrc.lrc import LRC, LRCOptimizer
from openlrc.transcribe import Transcriber
from openlrc.translate import Translator
from openlrc.utils import Timer, change_ext, extend_filename, get_audio_duration, format_timestamp


class LRCer:
    """
    :ivar model_name: Name of whisper model (tiny, tiny.en, base, base.en, small, small.en, medium,
                    medium.en, large-v1, or large-v2) When a size is configured, the converted model is downloaded
                    from the Hugging Face Hub.
                    Default: ``large-v2``
    :ivar fee_limit: The maximum fee you are willing to pay for translation. Default: ``0.1``
    """

    def __init__(self, model_name='large-v2', fee_limit=0.1):
        self.transcriber = Transcriber(model_name=model_name)
        self.fee_limit = fee_limit

    def __call__(self, audio_path, target_lang='zh-cn', prompter='base_trans'):
        transcribed_lrc_path = change_ext(extend_filename(audio_path, '_transcribed'), 'lrc')
        if not os.path.exists(transcribed_lrc_path):
            logger.info(f'Not found transcribed lrc file: {transcribed_lrc_path}')
            with Timer('Transcription process'):
                logger.info(f'Audio length: {audio_path}: {get_audio_duration(audio_path)}')
                segments, info = self.transcriber.transcribe(audio_path, batch_size=4)
                logger.info(f'Detected language: {info.language}')

                # From generator to list with progress bar shown
                seg_list = segments['sentences']  # [{'text': ..., 'start_word': ..., 'end_word':...}, ...]
                logger.debug(f'Transcribed fast-whisper Segments: {seg_list}')

            # Save the transcribed lrc
            self.to_lrc(seg_list, name=transcribed_lrc_path, lang=info.language)  # xxx_transcribed.lrc
        else:
            logger.info(f'Found transcribed lrc file: {transcribed_lrc_path}')

        transcribed_opt_path = self.post_process(transcribed_lrc_path)  # xxx_transcribed_optimized.lrc

        # Translate the transcribed lrc
        transcribed_opt_lrc = LRC(transcribed_opt_path)

        translator = Translator(prompter=prompter, fee_limit=self.fee_limit)

        with Timer('Translating...'):
            target_texts = translator.translate(transcribed_opt_lrc.get_texts(),
                                                src_lang=transcribed_opt_lrc.lang, target_lang=target_lang)
        transcribed_opt_lrc.set_texts(target_texts)
        translated_path = extend_filename(transcribed_opt_path, '_translated')
        transcribed_opt_lrc.save_lrc(translated_path)

        self.post_process(translated_path, output_lrc_name=change_ext(audio_path, 'lrc'), t2m=target_lang == 'zh-cn',
                          remove_files=[
                              transcribed_opt_path,  # xxx_transcribed_optimized.lrc
                              translated_path  # xxx_transcribed_optimized_translated.lrc
                          ])  # xxx.lrc

    @staticmethod
    def to_lrc(segments, name, lang):
        """
        Convert the segments into lrc format.
        """
        with open(name, 'w', encoding='utf-8') as f:
            print(f'LRC generated by https://github.com/zh-plus/Open-Lyrics, lang={lang}', file=f, flush=True)
            for i, segment in enumerate(segments):
                print(
                    f'[{format_timestamp(segment["start_word"]["start"])}] {segment["text"]}',
                    file=f,
                    flush=True,
                )

                print(f'[{format_timestamp(segment["end_word"]["end"])}]', file=f, flush=True)

        logger.info(f'File saved to {name}')

    @staticmethod
    def post_process(lrc_name, output_lrc_name=None, remove_files=None, t2m=False):
        lrc_optimizer = LRCOptimizer(lrc_name)
        lrc_optimizer.perform_all(t2m=t2m)
        optimized_name = lrc_optimizer.save(output_lrc_name=output_lrc_name)

        # Remove intermediate files
        if remove_files:
            for file in remove_files:
                os.remove(file)

        return optimized_name
